!(function (e, t) { typeof exports === 'object' && typeof module === 'object' ? module.exports = t() : typeof define === 'function' && define.amd ? define('StompJs', [], t) : typeof exports === 'object' ? exports.StompJs = t() : e.StompJs = t(); }(typeof self !== 'undefined' ? self : this, () => (function (e) { const t = {}; function n(o) { if (t[o]) return t[o].exports; const i = t[o] = { i: o, l: !1, exports: {} }; return e[o].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = e, n.c = t, n.d = function (e, t, o) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: o }); }, n.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, n.t = function (e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const o = Object.create(null); if (n.r(o), Object.defineProperty(o, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const i in e) n.d(o, i, (t => e[t]).bind(null, i)); return o; }, n.n = function (e) { const t = e && e.__esModule ? function () { return e.default; } : function () { return e; }; return n.d(t, 'a', t), t; }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, n.p = '', n(n.s = 7); }([function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = (function () { function e(e) { this.versions = e; } return e.prototype.supportedVersions = function () { return this.versions.join(','); }, e.prototype.protocolVersions = function () { return this.versions.map(e => `v${e.replace('.', '')}.stomp`); }, e.V1_0 = '1.0', e.V1_1 = '1.1', e.V1_2 = '1.2', e.default = new e([e.V1_0, e.V1_1, e.V1_2]), e; }()); t.Versions = o;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }), (function (e) { e[e.CONNECTING = 0] = 'CONNECTING', e[e.OPEN = 1] = 'OPEN', e[e.CLOSING = 2] = 'CLOSING', e[e.CLOSED = 3] = 'CLOSED'; }(t.WebSocketState || (t.WebSocketState = {})));
}, function (e, t, n) {
  const o = this && this.__awaiter || function (e, t, n, o) { return new (n || (n = Promise))(((i, r) => { function s(e) { try { a(o.next(e)); } catch (e) { r(e); } } function c(e) { try { a(o.throw(e)); } catch (e) { r(e); } } function a(e) { e.done ? i(e.value) : new n(((t) => { t(e.value); })).then(s, c); } a((o = o.apply(e, t || [])).next()); })); }; const
    i = this && this.__generator || function (e, t) {
      let n; let o; let i; let r; let
        s = {
          label: 0, sent() { if (1 & i[0]) throw i[1]; return i[1]; }, trys: [], ops: [],
        }; return r = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol === 'function' && (r[Symbol.iterator] = function () { return this; }), r; function c(r) { return function (c) { return (function (r) { if (n) throw new TypeError('Generator is already executing.'); for (; s;) try { if (n = 1, o && (i = 2 & r[0] ? o.return : r[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, r[1])).done) return i; switch (o = 0, i && (r = [2 & r[0], i.value]), r[0]) { case 0: case 1: i = r; break; case 4: return s.label++ , { value: r[1], done: !1 }; case 5: s.label++ , o = r[1], r = [0]; continue; case 7: r = s.ops.pop(), s.trys.pop(); continue; default: if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (r[0] === 6 || r[0] === 2)) { s = 0; continue; } if (r[0] === 3 && (!i || r[1] > i[0] && r[1] < i[3])) { s.label = r[1]; break; } if (r[0] === 6 && s.label < i[1]) { s.label = i[1], i = r; break; } if (i && s.label < i[2]) { s.label = i[2], s.ops.push(r); break; } i[2] && s.ops.pop(), s.trys.pop(); continue; }r = t.call(e, s); } catch (e) { r = [6, e], o = 0; } finally { n = i = 0; } if (5 & r[0]) throw r[1]; return { value: r[0] ? r[1] : void 0, done: !0 }; }([r, c])); }; }
    }; Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(9); const s = n(0); const c = n(1); const
      a = (function () {
        function e(e) { void 0 === e && (e = {}), this.stompVersions = s.Versions.default, this.reconnectDelay = 5e3, this.heartbeatIncoming = 1e4, this.heartbeatOutgoing = 1e4, this.splitLargeFrames = !1, this.maxWebSocketChunkSize = 8192, this.forceBinaryWSFrames = !1, this.appendMissingNULLonIncoming = !1, this._active = !1; const t = function () { }; this.debug = t, this.beforeConnect = t, this.onConnect = t, this.onDisconnect = t, this.onUnhandledMessage = t, this.onUnhandledReceipt = t, this.onUnhandledFrame = t, this.onStompError = t, this.onWebSocketClose = t, this.onWebSocketError = t, this.logRawCommunication = !1, this.connectHeaders = {}, this._disconnectHeaders = {}, this.configure(e); } return Object.defineProperty(e.prototype, 'webSocket', { get() { return this._webSocket; }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, 'disconnectHeaders', {
          get() { return this._disconnectHeaders; }, set(e) { this._disconnectHeaders = e, this._stompHandler && (this._stompHandler.disconnectHeaders = this._disconnectHeaders); }, enumerable: !0, configurable: !0,
        }), Object.defineProperty(e.prototype, 'connected', { get() { return !!this._stompHandler && this._stompHandler.connected; }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, 'connectedVersion', { get() { return this._stompHandler ? this._stompHandler.connectedVersion : void 0; }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, 'active', { get() { return this._active; }, enumerable: !0, configurable: !0 }), e.prototype.configure = function (e) { Object.assign(this, e); }, e.prototype.activate = function () { this._active = !0, this._connect(); }, e.prototype._connect = function () {
          return o(this, void 0, void 0, function () {
            const e = this; return i(this, function (t) {
              switch (t.label) {
                case 0: return this.connected ? (this.debug('STOMP: already connected, nothing to do'), [2]) : [4, this.beforeConnect()]; case 1: return t.sent(), this._active ? (this.debug('Opening Web Socket...'), this._webSocket = this._createWebSocket(), this._stompHandler = new r.StompHandler(this, this._webSocket, {
                  debug: this.debug, stompVersions: this.stompVersions, connectHeaders: this.connectHeaders, disconnectHeaders: this._disconnectHeaders, heartbeatIncoming: this.heartbeatIncoming, heartbeatOutgoing: this.heartbeatOutgoing, splitLargeFrames: this.splitLargeFrames, maxWebSocketChunkSize: this.maxWebSocketChunkSize, forceBinaryWSFrames: this.forceBinaryWSFrames, logRawCommunication: this.logRawCommunication, appendMissingNULLonIncoming: this.appendMissingNULLonIncoming, onConnect(t) { if (!e._active) return e.debug('STOMP got connected while deactivate was issued, will disconnect now'), void e._disposeStompHandler(); e.onConnect(t); }, onDisconnect(t) { e.onDisconnect(t); }, onStompError(t) { e.onStompError(t); }, onWebSocketClose(t) { e.onWebSocketClose(t), e._active && e._schedule_reconnect(); }, onWebSocketError(t) { e.onWebSocketError(t); }, onUnhandledMessage(t) { e.onUnhandledMessage(t); }, onUnhandledReceipt(t) { e.onUnhandledReceipt(t); }, onUnhandledFrame(t) { e.onUnhandledFrame(t); },
                }), this._stompHandler.start(), [2]) : (this.debug('Client has been marked inactive, will not attempt to connect'), [2]);
              }
            });
          });
        }, e.prototype._createWebSocket = function () { let e; return (e = this.webSocketFactory ? this.webSocketFactory() : new WebSocket(this.brokerURL, this.stompVersions.protocolVersions())).binaryType = 'arraybuffer', e; }, e.prototype._schedule_reconnect = function () { const e = this; this.reconnectDelay > 0 && (this.debug(`STOMP: scheduling reconnection in ${this.reconnectDelay}ms`), this._reconnector = setTimeout(() => { e._connect(); }, this.reconnectDelay)); }, e.prototype.deactivate = function () { this._active = !1, this._reconnector && clearTimeout(this._reconnector), this._disposeStompHandler(); }, e.prototype.forceDisconnect = function () { this._webSocket && (this._webSocket.readyState !== c.WebSocketState.CONNECTING && this._webSocket.readyState !== c.WebSocketState.OPEN || this._webSocket.close()); }, e.prototype._disposeStompHandler = function () { this._stompHandler && (this._stompHandler.dispose(), this._stompHandler = null); }, e.prototype.publish = function (e) { this._stompHandler.publish(e); }, e.prototype.watchForReceipt = function (e, t) { this._stompHandler.watchForReceipt(e, t); }, e.prototype.subscribe = function (e, t, n) { return void 0 === n && (n = {}), this._stompHandler.subscribe(e, t, n); }, e.prototype.unsubscribe = function (e, t) { void 0 === t && (t = {}), this._stompHandler.unsubscribe(e, t); }, e.prototype.begin = function (e) { return this._stompHandler.begin(e); }, e.prototype.commit = function (e) { this._stompHandler.commit(e); }, e.prototype.abort = function (e) { this._stompHandler.abort(e); }, e.prototype.ack = function (e, t, n) { void 0 === n && (n = {}), this._stompHandler.ack(e, t, n); }, e.prototype.nack = function (e, t, n) { void 0 === n && (n = {}), this._stompHandler.nack(e, t, n); }, e;
      }()); t.Client = a;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }), t.BYTE = { LF: '\n', NULL: '\0' };
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = n(3); const
    i = (function () {
      function e(e) {
        const t = e.command; const n = e.headers; const o = e.body; const i = e.binaryBody; const r = e.escapeHeaderValues; const
          s = e.skipContentLengthHeader; this.command = t, this.headers = Object.assign({}, n || {}), i ? (this._binaryBody = i, this.isBinaryBody = !0) : (this._body = o || '', this.isBinaryBody = !1), this.escapeHeaderValues = r || !1, this.skipContentLengthHeader = s || !1;
      } return Object.defineProperty(e.prototype, 'body', { get() { return !this._body && this.isBinaryBody && (this._body = (new TextDecoder()).decode(this._binaryBody)), this._body; }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, 'binaryBody', { get() { return this._binaryBody || this.isBinaryBody || (this._binaryBody = (new TextEncoder()).encode(this._body)), this._binaryBody; }, enumerable: !0, configurable: !0 }), e.fromRawFrame = function (t, n) {
        for (var o = {}, i = function (e) { return e.replace(/^\s+|\s+$/g, ''); }, r = 0, s = t.headers.reverse(); r < s.length; r++) {
          const c = s[r]; const a = (c.indexOf(':'), i(c[0])); let
            u = i(c[1]); n && t.command !== 'CONNECT' && t.command !== 'CONNECTED' && (u = e.hdrValueUnEscape(u)), o[a] = u;
        } return new e({
          command: t.command, headers: o, binaryBody: t.binaryBody, escapeHeaderValues: n,
        });
      }, e.prototype.toString = function () { return this.serializeCmdAndHeaders(); }, e.prototype.serialize = function () { const t = this.serializeCmdAndHeaders(); return this.isBinaryBody ? e.toUnit8Array(t, this._binaryBody).buffer : t + this._body + o.BYTE.NULL; }, e.prototype.serializeCmdAndHeaders = function () {
        const t = [this.command]; this.skipContentLengthHeader && delete this.headers['content-length']; for (let n = 0, i = Object.keys(this.headers || {}); n < i.length; n++) {
          const r = i[n]; const
            s = this.headers[r]; this.escapeHeaderValues && this.command !== 'CONNECT' && this.command !== 'CONNECTED' ? t.push(`${r}:${e.hdrValueEscape(`${s}`)}`) : t.push(`${r}:${s}`);
        } return (this.isBinaryBody || !this.isBodyEmpty() && !this.skipContentLengthHeader) && t.push(`content-length:${this.bodyLength()}`), t.join(o.BYTE.LF) + o.BYTE.LF + o.BYTE.LF;
      }, e.prototype.isBodyEmpty = function () { return this.bodyLength() === 0; }, e.prototype.bodyLength = function () { const e = this.binaryBody; return e ? e.length : 0; }, e.sizeOfUTF8 = function (e) { return e ? (new TextEncoder()).encode(e).length : 0; }, e.toUnit8Array = function (e, t) {
        const n = (new TextEncoder()).encode(e); const o = new Uint8Array([0]); const
          i = new Uint8Array(n.length + t.length + o.length); return i.set(n), i.set(t, n.length), i.set(o, n.length + t.length), i;
      }, e.marshall = function (t) { return new e(t).serialize(); }, e.hdrValueEscape = function (e) { return e.replace(/\\/g, '\\\\').replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/:/g, '\\c'); }, e.hdrValueUnEscape = function (e) { return e.replace(/\\r/g, '\r').replace(/\\n/g, '\n').replace(/\\c/g, ':').replace(/\\\\/g, '\\'); }, e;
    }()); t.FrameImpl = i;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = (function () { function e(e, t) { this.onFrame = e, this.onIncomingPing = t, this._encoder = new TextEncoder(), this._decoder = new TextDecoder(), this._token = [], this._initState(); } return e.prototype.parseChunk = function (e, t) { let n; if (void 0 === t && (t = !1), n = e instanceof ArrayBuffer ? new Uint8Array(e) : this._encoder.encode(e), t && n[n.length - 1] !== 0) { const o = new Uint8Array(n.length + 1); o.set(n, 0), o[n.length] = 0, n = o; } for (let i = 0; i < n.length; i++) { const r = n[i]; this._onByte(r); } }, e.prototype._collectFrame = function (e) { e !== 0 && e !== 13 && (e !== 10 ? (this._onByte = this._collectCommand, this._reinjectByte(e)) : this.onIncomingPing()); }, e.prototype._collectCommand = function (e) { if (e !== 13) return e === 10 ? (this._results.command = this._consumeTokenAsUTF8(), void (this._onByte = this._collectHeaders)) : void this._consumeByte(e); }, e.prototype._collectHeaders = function (e) { e !== 13 && (e !== 10 ? (this._onByte = this._collectHeaderKey, this._reinjectByte(e)) : this._setupCollectBody()); }, e.prototype._reinjectByte = function (e) { this._onByte(e); }, e.prototype._collectHeaderKey = function (e) { if (e === 58) return this._headerKey = this._consumeTokenAsUTF8(), void (this._onByte = this._collectHeaderValue); this._consumeByte(e); }, e.prototype._collectHeaderValue = function (e) { if (e !== 13) return e === 10 ? (this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]), this._headerKey = void 0, void (this._onByte = this._collectHeaders)) : void this._consumeByte(e); }, e.prototype._setupCollectBody = function () { const e = this._results.headers.filter(e => e[0] === 'content-length')[0]; e ? (this._bodyBytesRemaining = parseInt(e[1], 10), this._onByte = this._collectBodyFixedSize) : this._onByte = this._collectBodyNullTerminated; }, e.prototype._collectBodyNullTerminated = function (e) { e !== 0 ? this._consumeByte(e) : this._retrievedBody(); }, e.prototype._collectBodyFixedSize = function (e) { this._bodyBytesRemaining-- != 0 ? this._consumeByte(e) : this._retrievedBody(); }, e.prototype._retrievedBody = function () { this._results.binaryBody = this._consumeTokenAsRaw(), this.onFrame(this._results), this._initState(); }, e.prototype._consumeByte = function (e) { this._token.push(e); }, e.prototype._consumeTokenAsUTF8 = function () { return this._decoder.decode(this._consumeTokenAsRaw()); }, e.prototype._consumeTokenAsRaw = function () { const e = new Uint8Array(this._token); return this._token = [], e; }, e.prototype._initState = function () { this._results = { command: void 0, headers: [], binaryBody: void 0 }, this._token = [], this._headerKey = void 0, this._onByte = this._collectFrame; }, e; }()); t.Parser = o;
}, function (e, t, n) {
  let o; const
    i = this && this.__extends || (o = function (e, t) { return (o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n]); })(e, t); }, function (e, t) { function n() { this.constructor = e; } o(e, t), e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n()); }); Object.defineProperty(t, '__esModule', { value: !0 }); const r = n(2); const s = n(13); const
      c = (function (e) {
        function t(t) { const n = e.call(this) || this; return n.maxWebSocketFrameSize = 16384, n._heartbeatInfo = new s.HeartbeatInfo(n), n.reconnect_delay = 0, n.webSocketFactory = t, n.debug = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; console.log(...e); }, n; } return i(t, e), t.prototype._parseConnect = function () { for (var e, t, n, o = [], i = 0; i < arguments.length; i++)o[i] = arguments[i]; let r = {}; if (o.length < 2) throw new Error('Connect requires at least 2 arguments'); if (typeof o[1] === 'function') r = o[0], t = o[1], n = o[2], e = o[3]; else switch (o.length) { case 6: r.login = o[0], r.passcode = o[1], t = o[2], n = o[3], e = o[4], r.host = o[5]; break; default: r.login = o[0], r.passcode = o[1], t = o[2], n = o[3], e = o[4]; } return [r, t, n, e]; }, t.prototype.connect = function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; const o = this._parseConnect.apply(this, t); o[0] && (this.connectHeaders = o[0]), o[1] && (this.onConnect = o[1]), o[2] && (this.onStompError = o[2]), o[3] && (this.onWebSocketClose = o[3]), e.prototype.activate.call(this); }, t.prototype.disconnect = function (t, n) { void 0 === n && (n = {}), t && (this.onDisconnect = t), this.disconnectHeaders = n, e.prototype.deactivate.call(this); }, t.prototype.send = function (e, t, n) {
          void 0 === t && (t = {}), void 0 === n && (n = ''); const o = !1 === (t = Object.assign({}, t))['content-length']; o && delete t['content-length'], this.publish({
            destination: e, headers: t, body: n, skipContentLengthHeader: o,
          });
        }, Object.defineProperty(t.prototype, 'reconnect_delay', { set(e) { this.reconnectDelay = e; }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, 'ws', { get() { return this._webSocket; }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, 'version', { get() { return this.connectedVersion; }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, 'onreceive', {
          get() { return this.onUnhandledMessage; }, set(e) { this.onUnhandledMessage = e; }, enumerable: !0, configurable: !0,
        }), Object.defineProperty(t.prototype, 'onreceipt', {
          get() { return this.onUnhandledReceipt; }, set(e) { this.onUnhandledReceipt = e; }, enumerable: !0, configurable: !0,
        }), Object.defineProperty(t.prototype, 'heartbeat', {
          get() { return this._heartbeatInfo; }, set(e) { this.heartbeatIncoming = e.incoming, this.heartbeatOutgoing = e.outgoing; }, enumerable: !0, configurable: !0,
        }), t;
      }(r.Client)); t.CompatClient = c;
}, function (e, t, n) { e.exports = n(8); }, function (e, t, n) {
  function o(e) { for (const n in e) t.hasOwnProperty(n) || (t[n] = e[n]); } Object.defineProperty(t, '__esModule', { value: !0 }), o(n(2)), o(n(4)), o(n(5)), o(n(10)), o(n(11)), o(n(12)), o(n(0)), o(n(1)), o(n(6)), o(n(14));
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = n(3); const i = n(4); const r = n(5); const s = n(0); const c = n(1); const
    a = (function () {
      function e(e, t, n) {
        const o = this; void 0 === n && (n = {}), this._client = e, this._webSocket = t, this._serverFrameHandlers = {
          CONNECTED(e) { o.debug(`connected to server ${e.headers.server}`), o._connected = !0, o._connectedVersion = e.headers.version, o._connectedVersion === s.Versions.V1_2 && (o._escapeHeaderValues = !0), o._setupHeartbeat(e.headers), o.onConnect(e); },
          MESSAGE(e) {
            const t = e.headers.subscription; const n = o._subscriptions[t] || o.onUnhandledMessage; const i = e; const r = o; const
              c = o._connectedVersion === s.Versions.V1_2 ? i.headers.ack : i.headers['message-id']; i.ack = function (e) { return void 0 === e && (e = {}), r.ack(c, t, e); }, i.nack = function (e) { return void 0 === e && (e = {}), r.nack(c, t, e); }, n(i);
          },
          RECEIPT(e) { const t = o._receiptWatchers[e.headers['receipt-id']]; t ? (t(e), delete o._receiptWatchers[e.headers['receipt-id']]) : o.onUnhandledReceipt(e); },
          ERROR(e) { o.onStompError(e); },
        }, this._counter = 0, this._subscriptions = {}, this._receiptWatchers = {}, this._partialData = '', this._escapeHeaderValues = !1, this._lastServerActivityTS = Date.now(), this.configure(n);
      } return Object.defineProperty(e.prototype, 'connectedVersion', { get() { return this._connectedVersion; }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, 'connected', { get() { return this._connected; }, enumerable: !0, configurable: !0 }), e.prototype.configure = function (e) { Object.assign(this, e); }, e.prototype.start = function () {
        const e = this; const
          t = new r.Parser(((t) => { const n = i.FrameImpl.fromRawFrame(t, e._escapeHeaderValues); e.logRawCommunication || e.debug(`<<< ${n}`), (e._serverFrameHandlers[n.command] || e.onUnhandledFrame)(n); }), (() => { e.debug('<<< PONG'); })); this._webSocket.onmessage = function (n) { if (e.debug('Received data'), e._lastServerActivityTS = Date.now(), e.logRawCommunication) { const o = n.data instanceof ArrayBuffer ? (new TextDecoder()).decode(n.data) : n.data; e.debug(`<<< ${o}`); } t.parseChunk(n.data, e.appendMissingNULLonIncoming); }, this._webSocket.onclose = function (t) { e.debug(`Connection closed to ${e._webSocket.url}`), e.onWebSocketClose(t), e._cleanUp(); }, this._webSocket.onerror = function (t) { e.onWebSocketError(t); }, this._webSocket.onopen = function () { const t = Object.assign({}, e.connectHeaders); e.debug('Web Socket Opened...'), t['accept-version'] = e.stompVersions.supportedVersions(), t['heart-beat'] = [e.heartbeatOutgoing, e.heartbeatIncoming].join(','), e._transmit({ command: 'CONNECT', headers: t }); };
      }, e.prototype._setupHeartbeat = function (e) {
        const t = this; if (e.version === s.Versions.V1_1 || e.version === s.Versions.V1_2) {
          const n = e['heart-beat'].split(',').map(e => parseInt(e, 10)); const i = n[0]; const
            r = n[1]; if (this.heartbeatOutgoing !== 0 && r !== 0) { const a = Math.max(this.heartbeatOutgoing, r); this.debug(`send PING every ${a}ms`), this._pinger = setInterval(() => { t._webSocket.readyState === c.WebSocketState.OPEN && (t._webSocket.send(o.BYTE.LF), t.debug('>>> PING')); }, a); } if (this.heartbeatIncoming !== 0 && i !== 0) { const u = Math.max(this.heartbeatIncoming, i); this.debug(`check PONG every ${u}ms`), this._ponger = setInterval(() => { const e = Date.now() - t._lastServerActivityTS; e > 2 * u && (t.debug(`did not receive server activity for the last ${e}ms`), t._webSocket.close()); }, u); }
        }
      }, e.prototype._transmit = function (e) {
        const t = e.command; const n = e.headers; const o = e.body; const r = e.binaryBody; const s = e.skipContentLengthHeader; const c = new i.FrameImpl({
          command: t, headers: n, body: o, binaryBody: r, escapeHeaderValues: this._escapeHeaderValues, skipContentLengthHeader: s,
        }); let
          a = c.serialize(); if (this.logRawCommunication ? this.debug(`>>> ${a}`) : this.debug(`>>> ${c}`), this.forceBinaryWSFrames && typeof a === 'string' && (a = (new TextEncoder()).encode(a)), typeof a === 'string' && this.splitLargeFrames) for (let u = a; u.length > 0;) { const d = u.substring(0, this.maxWebSocketChunkSize); u = u.substring(this.maxWebSocketChunkSize), this._webSocket.send(d), this.debug(`chunk sent = ${d.length}, remaining = ${u.length}`); } else this._webSocket.send(a);
      }, e.prototype.dispose = function () { const e = this; if (this.connected) try { const t = Object.assign({}, this.disconnectHeaders); t.receipt || (t.receipt = `close-${this._counter++}`), this.watchForReceipt(t.receipt, (t) => { e._webSocket.close(), e._cleanUp(), e.onDisconnect(t); }), this._transmit({ command: 'DISCONNECT', headers: t }); } catch (e) { this.debug(`Ignoring error during disconnect ${e}`); } else this._webSocket.readyState !== c.WebSocketState.CONNECTING && this._webSocket.readyState !== c.WebSocketState.OPEN || this._webSocket.close(); }, e.prototype._cleanUp = function () { this._connected = !1, this._pinger && clearInterval(this._pinger), this._ponger && clearInterval(this._ponger); }, e.prototype.publish = function (e) {
        const t = e.destination; const n = e.headers; const o = e.body; const i = e.binaryBody; const r = e.skipContentLengthHeader; const
          s = Object.assign({ destination: t }, n); this._transmit({
            command: 'SEND', headers: s, body: o, binaryBody: i, skipContentLengthHeader: r,
          });
      }, e.prototype.watchForReceipt = function (e, t) { this._receiptWatchers[e] = t; }, e.prototype.subscribe = function (e, t, n) { void 0 === n && (n = {}), (n = Object.assign({}, n)).id || (n.id = `sub-${this._counter++}`), n.destination = e, this._subscriptions[n.id] = t, this._transmit({ command: 'SUBSCRIBE', headers: n }); const o = this; return { id: n.id, unsubscribe(e) { return o.unsubscribe(n.id, e); } }; }, e.prototype.unsubscribe = function (e, t) { void 0 === t && (t = {}), t = Object.assign({}, t), delete this._subscriptions[e], t.id = e, this._transmit({ command: 'UNSUBSCRIBE', headers: t }); }, e.prototype.begin = function (e) { const t = e || `tx-${this._counter++}`; this._transmit({ command: 'BEGIN', headers: { transaction: t } }); const n = this; return { id: t, commit() { n.commit(t); }, abort() { n.abort(t); } }; }, e.prototype.commit = function (e) { this._transmit({ command: 'COMMIT', headers: { transaction: e } }); }, e.prototype.abort = function (e) { this._transmit({ command: 'ABORT', headers: { transaction: e } }); }, e.prototype.ack = function (e, t, n) { void 0 === n && (n = {}), n = Object.assign({}, n), this._connectedVersion === s.Versions.V1_2 ? n.id = e : n['message-id'] = e, n.subscription = t, this._transmit({ command: 'ACK', headers: n }); }, e.prototype.nack = function (e, t, n) { return void 0 === n && (n = {}), n = Object.assign({}, n), this._connectedVersion === s.Versions.V1_2 ? n.id = e : n['message-id'] = e, n.subscription = t, this._transmit({ command: 'NACK', headers: n }); }, e;
    }()); t.StompHandler = a;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = (function () { return function () { }; }()); t.StompConfig = o;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = (function () { return function () { }; }()); t.StompHeaders = o;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = (function () { return function () { }; }()); t.StompSubscription = o;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = (function () {
    function e(e) { this.client = e; } return Object.defineProperty(e.prototype, 'outgoing', {
      get() { return this.client.heartbeatOutgoing; }, set(e) { this.client.heartbeatOutgoing = e; }, enumerable: !0, configurable: !0,
    }), Object.defineProperty(e.prototype, 'incoming', {
      get() { return this.client.heartbeatIncoming; }, set(e) { this.client.heartbeatIncoming = e; }, enumerable: !0, configurable: !0,
    }), e;
  }()); t.HeartbeatInfo = o;
}, function (e, t, n) {
  Object.defineProperty(t, '__esModule', { value: !0 }); const o = n(0); const i = n(6); const
    r = (function () { function e() { } return e.client = function (t, n) { n == null && (n = o.Versions.default.protocolVersions()); return new i.CompatClient((() => new (e.WebSocketClass || WebSocket)(t, n))); }, e.over = function (e) { let t; return typeof e === 'function' ? t = e : (console.warn('Stomp.over did not receive a factory, auto reconnect will not work. Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over'), t = function () { return e; }), new i.CompatClient(t); }, e.WebSocketClass = null, e; }()); t.Stomp = r;
}]))));
// # sourceMappingURL=stomp.umd.min.js.map
